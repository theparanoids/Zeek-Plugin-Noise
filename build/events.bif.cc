// This file was automatically generated by bifcl from /zeek-plugin-noise/src/events.bif (plugin mode).


#include "events.bif.h"

EventHandlerPtr noise_event; 
void BifEvent::generate_noise_event(analyzer::Analyzer* analyzer, Connection* c, bro_int_t itype, bro_int_t idata, StringVal* enc, StringVal* enc_static, StringVal* enc_timestamp, StringVal* mac1, StringVal* mac2)
	{
	// Note that it is intentional that here we do not
	// check if ::noise_event is NULL, which should happen *before*
	// BifEvent::generate_noise_event is called to avoid unnecessary Val
	// allocation.

	mgr.QueueEventFast(::noise_event, val_list{
	        c->BuildConnVal(),
	        val_mgr->GetInt(itype),
	        val_mgr->GetInt(idata),
	        enc,
	        enc_static,
	        enc_timestamp,
	        mac1,
	        mac2,
	        },
	    SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr noise_initiation; 
void BifEvent::generate_noise_initiation(analyzer::Analyzer* analyzer, Connection* c, bro_int_t idata, StringVal* enc, StringVal* enc_static, StringVal* enc_timestamp, StringVal* mac1, StringVal* mac2)
	{
	// Note that it is intentional that here we do not
	// check if ::noise_initiation is NULL, which should happen *before*
	// BifEvent::generate_noise_initiation is called to avoid unnecessary Val
	// allocation.

	mgr.QueueEventFast(::noise_initiation, val_list{
	        c->BuildConnVal(),
	        val_mgr->GetInt(idata),
	        enc,
	        enc_static,
	        enc_timestamp,
	        mac1,
	        mac2,
	        },
	    SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr noise_response; 
void BifEvent::generate_noise_response(analyzer::Analyzer* analyzer, Connection* c, bro_int_t sender, bro_int_t receiver, StringVal* unenc, StringVal* enc_nothing, StringVal* mac1, StringVal* mac2)
	{
	// Note that it is intentional that here we do not
	// check if ::noise_response is NULL, which should happen *before*
	// BifEvent::generate_noise_response is called to avoid unnecessary Val
	// allocation.

	mgr.QueueEventFast(::noise_response, val_list{
	        c->BuildConnVal(),
	        val_mgr->GetInt(sender),
	        val_mgr->GetInt(receiver),
	        unenc,
	        enc_nothing,
	        mac1,
	        mac2,
	        },
	    SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr noise_cookie; 
void BifEvent::generate_noise_cookie(analyzer::Analyzer* analyzer, Connection* c, bro_int_t receiver)
	{
	// Note that it is intentional that here we do not
	// check if ::noise_cookie is NULL, which should happen *before*
	// BifEvent::generate_noise_cookie is called to avoid unnecessary Val
	// allocation.

	mgr.QueueEventFast(::noise_cookie, val_list{
	        c->BuildConnVal(),
	        val_mgr->GetInt(receiver),
	        },
	    SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
EventHandlerPtr noise_transport; 
void BifEvent::generate_noise_transport(analyzer::Analyzer* analyzer, Connection* c, bro_int_t receiver, bro_int_t iCount)
	{
	// Note that it is intentional that here we do not
	// check if ::noise_transport is NULL, which should happen *before*
	// BifEvent::generate_noise_transport is called to avoid unnecessary Val
	// allocation.

	mgr.QueueEventFast(::noise_transport, val_list{
	        c->BuildConnVal(),
	        val_mgr->GetInt(receiver),
	        val_mgr->GetInt(iCount),
	        },
	    SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
