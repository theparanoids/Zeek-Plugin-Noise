// This file is automatically generated from /zeek-plugin-noise/src/noise.pac.

#ifndef _zeek_plugin_noise_src_noise_pac_h
#define _zeek_plugin_noise_src_noise_pac_h

#include <vector>

#include "binpac.h"


#include "binpac_bro.h"


	#include "events.bif.h"

namespace binpac {

namespace NOISE {
class ContextNOISE;
class NOISE_PDU;
class NOISE_INITIATION;
class NOISE_RESPONSE;
class NOISE_COOKIE;
class NOISE_TRANSPORT;
class NOISE_Conn;
class NOISE_Flow;
} // namespace NOISE

int bytestring_to_int(const_bytestring const & s, int base);
double bytestring_to_double(const_bytestring const & s);
int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2);
bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2);
double network_time();
StringVal * utf16_bytestring_to_utf8_val(Connection * conn, bytestring const & utf16);
namespace NOISE {

class ContextNOISE
{
public:
	ContextNOISE(NOISE_Conn * connection, NOISE_Flow * flow);
	~ContextNOISE();
	
	// Member access functions
	NOISE_Conn * connection() const { return connection_; }
	NOISE_Flow * flow() const { return flow_; }
	
protected:
	NOISE_Conn * connection_;
	NOISE_Flow * flow_;
};


class NOISE_PDU
{
public:
	NOISE_PDU();
	~NOISE_PDU();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context);
	
	// Member access functions
	uint8 itype() const { return itype_; }
	uint8 data_case_index() const	{ return data_case_index_; }
	NOISE_INITIATION * iinitial() const
		{
		switch ( data_case_index() )
			{
			case ((uint8) 1):
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/zeek-plugin-noise/src/noise-protocol.pac:23:iinitial", (int64)data_case_index(), "((int) 1)");
				break;
			}
		return iinitial_;
		}
	NOISE_RESPONSE * iresponse() const
		{
		switch ( data_case_index() )
			{
			case ((uint8) 2):
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/zeek-plugin-noise/src/noise-protocol.pac:24:iresponse", (int64)data_case_index(), "((int) 2)");
				break;
			}
		return iresponse_;
		}
	NOISE_COOKIE * icookie() const
		{
		switch ( data_case_index() )
			{
			case ((uint8) 3):
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/zeek-plugin-noise/src/noise-protocol.pac:25:icookie", (int64)data_case_index(), "((int) 3)");
				break;
			}
		return icookie_;
		}
	NOISE_TRANSPORT * itransport() const
		{
		switch ( data_case_index() )
			{
			case ((uint8) 4):
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("/zeek-plugin-noise/src/noise-protocol.pac:26:itransport", (int64)data_case_index(), "((int) 4)");
				break;
			}
		return itransport_;
		}
	int byteorder() const { return byteorder_; }
	bool proc() const { return proc_; }
	
protected:
	uint8 itype_;
	uint8 data_case_index_;
	NOISE_INITIATION * iinitial_;
	NOISE_RESPONSE * iresponse_;
	NOISE_COOKIE * icookie_;
	NOISE_TRANSPORT * itransport_;
	int byteorder_;
	bool proc_;
};


class NOISE_INITIATION
{
public:
	NOISE_INITIATION();
	~NOISE_INITIATION();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context);
	
	// Member access functions
	uint32 sender_index() const { return sender_index_; }
	bytestring const & unenc() const { return unenc_; }
	bytestring const & enc_static() const { return enc_static_; }
	bytestring const & enc_timestamp() const { return enc_timestamp_; }
	bytestring const & mac1() const { return mac1_; }
	bytestring const & mac2() const { return mac2_; }
	bool proc() const { return proc_; }
	
protected:
	uint32 sender_index_;
	bytestring unenc_;
	bytestring enc_static_;
	bytestring enc_timestamp_;
	bytestring mac1_;
	bytestring mac2_;
	bool proc_;
};


class NOISE_RESPONSE
{
public:
	NOISE_RESPONSE();
	~NOISE_RESPONSE();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context);
	
	// Member access functions
	uint32 sender_index() const { return sender_index_; }
	uint32 receiver_index() const { return receiver_index_; }
	bytestring const & unenc_ephemeral() const { return unenc_ephemeral_; }
	bytestring const & enc_nothing() const { return enc_nothing_; }
	bytestring const & mac1() const { return mac1_; }
	bytestring const & mac2() const { return mac2_; }
	bool proc() const { return proc_; }
	
protected:
	uint32 sender_index_;
	uint32 receiver_index_;
	bytestring unenc_ephemeral_;
	bytestring enc_nothing_;
	bytestring mac1_;
	bytestring mac2_;
	bool proc_;
};


class NOISE_COOKIE
{
public:
	NOISE_COOKIE();
	~NOISE_COOKIE();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context);
	
	// Member access functions
	uint32 receiver_index() const { return receiver_index_; }
	bytestring const & nonce() const { return nonce_; }
	vector<uint8> * encrypted_cookie() const { return encrypted_cookie_; }
	bool proc() const { return proc_; }
	
protected:
	uint32 receiver_index_;
	bytestring nonce_;
	vector<uint8> * encrypted_cookie_;
	uint8 encrypted_cookie__elem_;
	bool proc_;
};


class NOISE_TRANSPORT
{
public:
	NOISE_TRANSPORT();
	~NOISE_TRANSPORT();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context);
	
	// Member access functions
	uint32 receiver_index() const { return receiver_index_; }
	uint64 counter() const { return counter_; }
	bytestring const & enc_packet() const { return enc_packet_; }
	bool proc() const { return proc_; }
	
protected:
	uint32 receiver_index_;
	uint64 counter_;
	bytestring enc_packet_;
	bool proc_;
};


class NOISE_Conn : public binpac::ConnectionAnalyzer
{
public:
	NOISE_Conn(BroAnalyzer const & bro_analyzer);
	~NOISE_Conn();
	
	// Member access functions
	NOISE_Flow * upflow() const { return upflow_; }
	NOISE_Flow * downflow() const { return downflow_; }
	BroAnalyzer const & bro_analyzer() const { return bro_analyzer_; }
	
	void NewData(bool is_orig, const_byteptr begin, const_byteptr end);
	void NewGap(bool is_orig, int gap_length);
	void FlowEOF(bool is_orig);
	
protected:
	NOISE_Flow * upflow_;
	NOISE_Flow * downflow_;
	BroAnalyzer bro_analyzer_;
};


class NOISE_Flow : public binpac::FlowAnalyzer
{
public:
	NOISE_Flow(NOISE_Conn * connection, bool is_orig);
	~NOISE_Flow();
	
	// Member access functions
	NOISE_Conn * connection() const { return connection_; }
	bool is_orig() const { return is_orig_; }
	
	void NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data);
	void NewGap(int gap_length);
	void FlowEOF();
	
	// Functions
	bool proc_noise_message(NOISE_PDU * msg);
	bool proc_noise_initiation(NOISE_INITIATION * msg);
	bool proc_noise_response(NOISE_RESPONSE * msg);
	bool proc_noise_cookie(NOISE_COOKIE * msg);
	bool proc_noise_transport(NOISE_TRANSPORT * msg);
	
protected:
	NOISE_PDU * dataunit_;
	ContextNOISE * context_;
	NOISE_Conn * connection_;
	bool is_orig_;
};

} // namespace NOISE
}  // namespace binpac
#endif /* _zeek_plugin_noise_src_noise_pac_h */
