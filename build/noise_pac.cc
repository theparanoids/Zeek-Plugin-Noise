// This file is automatically generated from /zeek-plugin-noise/src/noise.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/zeek-plugin-noise/build/noise_pac.h"

namespace binpac {







namespace NOISE {
ContextNOISE::ContextNOISE(NOISE_Conn * connection, NOISE_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextNOISE::~ContextNOISE()
	{
	}

NOISE_PDU::NOISE_PDU()
	{
	itype_ = 0;
	data_case_index_ = -1;
	iinitial_ = 0;
	iresponse_ = 0;
	icookie_ = 0;
	itransport_ = 0;
	byteorder_ = bigendian;
	proc_ = 0;
	}

NOISE_PDU::~NOISE_PDU()
	{
	switch ( data_case_index() )
		{
		case ((uint8) 1):
			// Clean up "iinitial"
			{
			delete iinitial_;
			iinitial_ = 0;
			}
			break;
		case ((uint8) 2):
			// Clean up "iresponse"
			{
			delete iresponse_;
			iresponse_ = 0;
			}
			break;
		case ((uint8) 3):
			// Clean up "icookie"
			{
			delete icookie_;
			icookie_ = 0;
			}
			break;
		case ((uint8) 4):
			// Clean up "itransport"
			{
			delete itransport_;
			itransport_ = 0;
			}
			break;
		}
	}

int NOISE_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context)
	{
	// Checking out-of-bound for "NOISE_PDU:res_zero"
	if ( (t_begin_of_data + 1) + (3) > t_end_of_data || (t_begin_of_data + 1) + (3) < (t_begin_of_data + 1) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_PDU:res_zero",
			(1) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "itype"
	itype_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	
	// Parse "data"
	int t_data__size;
	data_case_index_ = itype();
	switch ( data_case_index() )
		{
		case ((uint8) 1):
			// Parse "iinitial"
			{
			iinitial_ = new NOISE_INITIATION();
			int t_iinitial__size;
			t_iinitial__size = iinitial_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_iinitial__size;
			}
			break;
		case ((uint8) 2):
			// Parse "iresponse"
			{
			iresponse_ = new NOISE_RESPONSE();
			int t_iresponse__size;
			t_iresponse__size = iresponse_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_iresponse__size;
			}
			break;
		case ((uint8) 3):
			// Parse "icookie"
			{
			icookie_ = new NOISE_COOKIE();
			int t_icookie__size;
			t_icookie__size = icookie_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_icookie__size;
			}
			break;
		case ((uint8) 4):
			// Parse "itransport"
			{
			itransport_ = new NOISE_TRANSPORT();
			int t_itransport__size;
			t_itransport__size = itransport_->Parse((t_begin_of_data + 4), t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_itransport__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("NOISE_PDU", (int64)data_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_NOISE_PDU__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_NOISE_PDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_noise_message(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NOISE_PDU__size) <= t_end_of_data);
	return t_NOISE_PDU__size;
	}

NOISE_INITIATION::NOISE_INITIATION()
	{
	sender_index_ = 0;
	proc_ = 0;
	}

NOISE_INITIATION::~NOISE_INITIATION()
	{
	unenc_.free();
	enc_static_.free();
	enc_timestamp_.free();
	mac1_.free();
	mac2_.free();
	}

int NOISE_INITIATION::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context)
	{
	// Checking out-of-bound for "NOISE_INITIATION:sender_index"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_INITIATION:sender_index",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sender_index"
	sender_index_ = FixByteOrder(littleendian, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "unenc"
	// Checking out-of-bound for "NOISE_INITIATION:unenc"
	if ( (t_begin_of_data + 4) + (32) > t_end_of_data || (t_begin_of_data + 4) + (32) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_INITIATION:unenc",
			(4) + (32), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 32;
	int t_unenc_string_length;
	t_unenc_string_length = 32;
	int t_unenc__size;
	t_unenc__size = t_unenc_string_length;
	unenc_.init((t_begin_of_data + 4), t_unenc_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_unenc = (t_begin_of_data + 4) + (32);
	BINPAC_ASSERT(t_dataptr_after_unenc <= t_end_of_data);
	// Parse "enc_static"
	// Checking out-of-bound for "NOISE_INITIATION:enc_static"
	if ( t_dataptr_after_unenc + (48) > t_end_of_data || t_dataptr_after_unenc + (48) < t_dataptr_after_unenc )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_INITIATION:enc_static",
			((t_dataptr_after_unenc - t_begin_of_data)) + (48), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_unenc + 48;
	int t_enc_static_string_length;
	t_enc_static_string_length = 48;
	int t_enc_static__size;
	t_enc_static__size = t_enc_static_string_length;
	enc_static_.init(t_dataptr_after_unenc, t_enc_static_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_enc_static = t_dataptr_after_unenc + (48);
	BINPAC_ASSERT(t_dataptr_after_enc_static <= t_end_of_data);
	// Parse "enc_timestamp"
	// Checking out-of-bound for "NOISE_INITIATION:enc_timestamp"
	if ( t_dataptr_after_enc_static + (28) > t_end_of_data || t_dataptr_after_enc_static + (28) < t_dataptr_after_enc_static )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_INITIATION:enc_timestamp",
			((t_dataptr_after_enc_static - t_begin_of_data)) + (28), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_enc_static + 28;
	int t_enc_timestamp_string_length;
	t_enc_timestamp_string_length = 28;
	int t_enc_timestamp__size;
	t_enc_timestamp__size = t_enc_timestamp_string_length;
	enc_timestamp_.init(t_dataptr_after_enc_static, t_enc_timestamp_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_enc_timestamp = t_dataptr_after_enc_static + (28);
	BINPAC_ASSERT(t_dataptr_after_enc_timestamp <= t_end_of_data);
	// Parse "mac1"
	// Checking out-of-bound for "NOISE_INITIATION:mac1"
	if ( t_dataptr_after_enc_timestamp + (16) > t_end_of_data || t_dataptr_after_enc_timestamp + (16) < t_dataptr_after_enc_timestamp )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_INITIATION:mac1",
			((t_dataptr_after_enc_timestamp - t_begin_of_data)) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_enc_timestamp + 16;
	int t_mac1_string_length;
	t_mac1_string_length = 16;
	int t_mac1__size;
	t_mac1__size = t_mac1_string_length;
	mac1_.init(t_dataptr_after_enc_timestamp, t_mac1_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_mac1 = t_dataptr_after_enc_timestamp + (16);
	BINPAC_ASSERT(t_dataptr_after_mac1 <= t_end_of_data);
	// Parse "mac2"
	// Checking out-of-bound for "NOISE_INITIATION:mac2"
	if ( t_dataptr_after_mac1 + (16) > t_end_of_data || t_dataptr_after_mac1 + (16) < t_dataptr_after_mac1 )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_INITIATION:mac2",
			((t_dataptr_after_mac1 - t_begin_of_data)) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_mac1 + 16;
	int t_mac2_string_length;
	t_mac2_string_length = 16;
	int t_mac2__size;
	t_mac2__size = t_mac2_string_length;
	mac2_.init(t_dataptr_after_mac1, t_mac2_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_NOISE_INITIATION__size;
	const_byteptr const t_dataptr_after_mac2 = t_dataptr_after_mac1 + (16);
	BINPAC_ASSERT(t_dataptr_after_mac2 <= t_end_of_data);
	t_NOISE_INITIATION__size = t_dataptr_after_mac2 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_noise_initiation(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NOISE_INITIATION__size) <= t_end_of_data);
	return t_NOISE_INITIATION__size;
	}

NOISE_RESPONSE::NOISE_RESPONSE()
	{
	sender_index_ = 0;
	receiver_index_ = 0;
	proc_ = 0;
	}

NOISE_RESPONSE::~NOISE_RESPONSE()
	{
	unenc_ephemeral_.free();
	enc_nothing_.free();
	mac1_.free();
	mac2_.free();
	}

int NOISE_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context)
	{
	// Checking out-of-bound for "NOISE_RESPONSE:receiver_index"
	if ( (t_begin_of_data + 4) + (4) > t_end_of_data || (t_begin_of_data + 4) + (4) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_RESPONSE:receiver_index",
			(4) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sender_index"
	sender_index_ = FixByteOrder(littleendian, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "receiver_index"
	receiver_index_ = FixByteOrder(littleendian, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "unenc_ephemeral"
	// Checking out-of-bound for "NOISE_RESPONSE:unenc_ephemeral"
	if ( (t_begin_of_data + 8) + (32) > t_end_of_data || (t_begin_of_data + 8) + (32) < (t_begin_of_data + 8) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_RESPONSE:unenc_ephemeral",
			(8) + (32), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 8) + 32;
	int t_unenc_ephemeral_string_length;
	t_unenc_ephemeral_string_length = 32;
	int t_unenc_ephemeral__size;
	t_unenc_ephemeral__size = t_unenc_ephemeral_string_length;
	unenc_ephemeral_.init((t_begin_of_data + 8), t_unenc_ephemeral_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_unenc_ephemeral = (t_begin_of_data + 8) + (32);
	BINPAC_ASSERT(t_dataptr_after_unenc_ephemeral <= t_end_of_data);
	// Parse "enc_nothing"
	// Checking out-of-bound for "NOISE_RESPONSE:enc_nothing"
	if ( t_dataptr_after_unenc_ephemeral + (16) > t_end_of_data || t_dataptr_after_unenc_ephemeral + (16) < t_dataptr_after_unenc_ephemeral )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_RESPONSE:enc_nothing",
			((t_dataptr_after_unenc_ephemeral - t_begin_of_data)) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_unenc_ephemeral + 16;
	int t_enc_nothing_string_length;
	t_enc_nothing_string_length = 16;
	int t_enc_nothing__size;
	t_enc_nothing__size = t_enc_nothing_string_length;
	enc_nothing_.init(t_dataptr_after_unenc_ephemeral, t_enc_nothing_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_enc_nothing = t_dataptr_after_unenc_ephemeral + (16);
	BINPAC_ASSERT(t_dataptr_after_enc_nothing <= t_end_of_data);
	// Parse "mac1"
	// Checking out-of-bound for "NOISE_RESPONSE:mac1"
	if ( t_dataptr_after_enc_nothing + (16) > t_end_of_data || t_dataptr_after_enc_nothing + (16) < t_dataptr_after_enc_nothing )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_RESPONSE:mac1",
			((t_dataptr_after_enc_nothing - t_begin_of_data)) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_enc_nothing + 16;
	int t_mac1_string_length;
	t_mac1_string_length = 16;
	int t_mac1__size;
	t_mac1__size = t_mac1_string_length;
	mac1_.init(t_dataptr_after_enc_nothing, t_mac1_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_mac1 = t_dataptr_after_enc_nothing + (16);
	BINPAC_ASSERT(t_dataptr_after_mac1 <= t_end_of_data);
	// Parse "mac2"
	// Checking out-of-bound for "NOISE_RESPONSE:mac2"
	if ( t_dataptr_after_mac1 + (16) > t_end_of_data || t_dataptr_after_mac1 + (16) < t_dataptr_after_mac1 )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_RESPONSE:mac2",
			((t_dataptr_after_mac1 - t_begin_of_data)) + (16), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = t_dataptr_after_mac1 + 16;
	int t_mac2_string_length;
	t_mac2_string_length = 16;
	int t_mac2__size;
	t_mac2__size = t_mac2_string_length;
	mac2_.init(t_dataptr_after_mac1, t_mac2_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	int t_NOISE_RESPONSE__size;
	const_byteptr const t_dataptr_after_mac2 = t_dataptr_after_mac1 + (16);
	BINPAC_ASSERT(t_dataptr_after_mac2 <= t_end_of_data);
	t_NOISE_RESPONSE__size = t_dataptr_after_mac2 - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_noise_response(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NOISE_RESPONSE__size) <= t_end_of_data);
	return t_NOISE_RESPONSE__size;
	}

NOISE_COOKIE::NOISE_COOKIE()
	{
	receiver_index_ = 0;
	encrypted_cookie_ = 0;
	encrypted_cookie__elem_ = 0;
	proc_ = 0;
	}

NOISE_COOKIE::~NOISE_COOKIE()
	{
	nonce_.free();
	delete encrypted_cookie_;
	}

int NOISE_COOKIE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context)
	{
	// Checking out-of-bound for "NOISE_COOKIE:receiver_index"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_COOKIE:receiver_index",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "receiver_index"
	receiver_index_ = FixByteOrder(littleendian, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "nonce"
	// Checking out-of-bound for "NOISE_COOKIE:nonce"
	if ( (t_begin_of_data + 4) + (256) > t_end_of_data || (t_begin_of_data + 4) + (256) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_COOKIE:nonce",
			(4) + (256), 
			(t_end_of_data) - (t_begin_of_data));
		}
	{
	// Setting t_end_of_data with &length
	const_byteptr t_end_of_data = (t_begin_of_data + 4) + 256;
	int t_nonce_string_length;
	t_nonce_string_length = 256;
	int t_nonce__size;
	t_nonce__size = t_nonce_string_length;
	nonce_.init((t_begin_of_data + 4), t_nonce_string_length);
	// Evaluate 'let' and 'withinput' fields
	}
	
	const_byteptr const t_dataptr_after_nonce = (t_begin_of_data + 4) + (256);
	BINPAC_ASSERT(t_dataptr_after_nonce <= t_end_of_data);
	// Checking out-of-bound for "NOISE_COOKIE:encrypted_cookie"
	if ( t_dataptr_after_nonce + (32) > t_end_of_data || t_dataptr_after_nonce + (32) < t_dataptr_after_nonce )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_COOKIE:encrypted_cookie",
			((t_dataptr_after_nonce - t_begin_of_data)) + (32), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "encrypted_cookie"
	int t_encrypted_cookie__arraylength;
	t_encrypted_cookie__arraylength = 0;
	t_encrypted_cookie__arraylength = 32;
	if ( t_encrypted_cookie__arraylength < 0 )
		{
		throw binpac::ExceptionOutOfBound("NOISE_COOKIE:encrypted_cookie",
		  t_encrypted_cookie__arraylength, (t_end_of_data) - (t_begin_of_data));
		}
	// Check bounds for static-size array: NOISE_COOKIE:encrypted_cookie
	if ( t_encrypted_cookie__arraylength > ((t_end_of_data - t_dataptr_after_nonce) / 1) )
		throw binpac::ExceptionOutOfBound("NOISE_COOKIE:encrypted_cookie",
		  t_encrypted_cookie__arraylength, (t_end_of_data) - (t_dataptr_after_nonce));
	encrypted_cookie__elem_ = 0;
	int t_encrypted_cookie__elem__it;
	t_encrypted_cookie__elem__it = 0;
	encrypted_cookie_ = new vector<uint8>;
	encrypted_cookie_->reserve(t_encrypted_cookie__arraylength);
	const_byteptr t_encrypted_cookie__elem__dataptr = t_dataptr_after_nonce;
	for (; t_encrypted_cookie__elem__it < t_encrypted_cookie__arraylength; ++t_encrypted_cookie__elem__it)
		{
		encrypted_cookie__elem_ = *((uint8 const *) (t_encrypted_cookie__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		encrypted_cookie_->push_back(encrypted_cookie__elem_);
		t_encrypted_cookie__elem__dataptr += 1;
		BINPAC_ASSERT(t_encrypted_cookie__elem__dataptr <= t_end_of_data);
		}
end_of_encrypted_cookie: ;
	// Evaluate 'let' and 'withinput' fields
	
	int t_NOISE_COOKIE__size;
	t_NOISE_COOKIE__size = (t_dataptr_after_nonce + 32) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_noise_cookie(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NOISE_COOKIE__size) <= t_end_of_data);
	return t_NOISE_COOKIE__size;
	}

NOISE_TRANSPORT::NOISE_TRANSPORT()
	{
	receiver_index_ = 0;
	counter_ = 0;
	proc_ = 0;
	}

NOISE_TRANSPORT::~NOISE_TRANSPORT()
	{
	enc_packet_.free();
	}

int NOISE_TRANSPORT::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextNOISE * t_context)
	{
	// Checking out-of-bound for "NOISE_TRANSPORT:counter"
	if ( (t_begin_of_data + 4) + (8) > t_end_of_data || (t_begin_of_data + 4) + (8) < (t_begin_of_data + 4) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOISE_TRANSPORT:counter",
			(4) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "receiver_index"
	receiver_index_ = FixByteOrder(littleendian, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "counter"
	counter_ = FixByteOrder(littleendian, *((uint64 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "enc_packet"
	int t_enc_packet_string_length;
	t_enc_packet_string_length = (t_end_of_data) - ((t_begin_of_data + 12));
	int t_enc_packet__size;
	t_enc_packet__size = t_enc_packet_string_length;
	// check for negative sizes
	if ( t_enc_packet_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/zeek-plugin-noise/src/noise-protocol.pac:58", t_enc_packet_string_length);
	enc_packet_.init((t_begin_of_data + 12), t_enc_packet_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_NOISE_TRANSPORT__size;
	const_byteptr const t_dataptr_after_enc_packet = (t_begin_of_data + 12) + (t_enc_packet__size);
	BINPAC_ASSERT(t_dataptr_after_enc_packet <= t_end_of_data);
	t_NOISE_TRANSPORT__size = t_dataptr_after_enc_packet - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_noise_transport(this);
	BINPAC_ASSERT(t_begin_of_data + (t_NOISE_TRANSPORT__size) <= t_end_of_data);
	return t_NOISE_TRANSPORT__size;
	}

NOISE_Conn::NOISE_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new NOISE_Flow(this, true);
	downflow_ = new NOISE_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

NOISE_Conn::~NOISE_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void NOISE_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void NOISE_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void NOISE_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

NOISE_Flow::NOISE_Flow(NOISE_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

NOISE_Flow::~NOISE_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void NOISE_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new NOISE_PDU();
		context_ = new ContextNOISE(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void NOISE_Flow::NewGap(int gap_length)
	{
	}
void NOISE_Flow::FlowEOF()
	{
	}
bool NOISE_Flow::proc_noise_message(NOISE_PDU * msg)
	{

                if ( msg->itype() == 1 ) 
			BifEvent::generate_noise_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(), msg->itype(),
		msg->iinitial()->sender_index(), 
		bytestring_to_val(msg->iinitial()->unenc()),
		bytestring_to_val(msg->iinitial()->enc_static()),
		bytestring_to_val(msg->iinitial()->enc_timestamp()),
		bytestring_to_val(msg->iinitial()->mac1()),
		bytestring_to_val(msg->iinitial()->mac2())
                  );
		return true;
		
	}

bool NOISE_Flow::proc_noise_initiation(NOISE_INITIATION * msg)
	{

                        BifEvent::generate_noise_initiation(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
                msg->sender_index(),
                bytestring_to_val(msg->unenc()),
                bytestring_to_val(msg->enc_static()),
                bytestring_to_val(msg->enc_timestamp()),
                bytestring_to_val(msg->mac1()),
                bytestring_to_val(msg->mac2())

                  );
		return true;
		
	}

bool NOISE_Flow::proc_noise_response(NOISE_RESPONSE * msg)
	{

                        BifEvent::generate_noise_response(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
		msg->sender_index(),
		msg->receiver_index(),
                bytestring_to_val(msg->unenc_ephemeral()),
                bytestring_to_val(msg->enc_nothing()),
                bytestring_to_val(msg->mac1()),
                bytestring_to_val(msg->mac2())
                  );
                return true;
                
	}

bool NOISE_Flow::proc_noise_cookie(NOISE_COOKIE * msg)
	{

                   BifEvent::generate_noise_cookie(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
                msg->receiver_index()
                  );
                return true;
                
	}

bool NOISE_Flow::proc_noise_transport(NOISE_TRANSPORT * msg)
	{

                   BifEvent::generate_noise_transport(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
                msg->receiver_index(),
		msg->counter()
                  );
                return true;
                
	}

} // namespace NOISE
}  // namespace binpac
